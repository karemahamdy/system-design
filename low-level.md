
#  Low-Level Design
LLD, or Low-Level Design, is a phase in the software development process where detailed system components and their interactions are specified. It involves converting the high-level design into a more detailed blueprint, addressing specific algorithms, data structures, and interfaces. LLD serves as a guide for developers during coding, which ensures the accurate and efficient implementation of the system’s functionality.

## `Roadmap to form LLD from HLD?`
 As we know, input for framing low-level design (LLD) is (High-Level Design) HLD. For this conversion, we generally use Unified Modelling Language (UML) diagrams. Adding to these diagrams we use OOPS principles and SOLID principles and design patterns 

 - `Step 1: Object-oriented Principles`
   
    The user requirement is processed by using concepts of OOPS programming. Hence it is recommended to have a strong grip on OOPS concepts prior to moving ahead in designing any low-level system. Programmers should be absolutely clear about the OOPS concepts to depth right to classes, and objects because OOPS is the foundation on which low-leveling on any system is based. 

- `Step 2. Process of analyzing and design`

    ming real-world problems into object-world problems using OOPS concepts and SOLID principles. 

- `Step 3. Design Patterns`
  
    Now the implementation of our above object oriented problem is carried out with the help of design patterns. Design patterns are reusable solutions to common problems encountered in software design. They provide a structured approach to design by capturing best practices and proven solutions, making it easier to develop scalable, maintainable, and efficient software.

- `Step 4. UML Diagram`
   
    UML (Unified Modeling Language) diagrams play an important role in converting HLD to LLD. They provide a proper and clear visual representation of the components and their relationships, which helps developers significantly

- `5. SOLID Principles`

  These are sets of 5 principles(rules) that are strictly followed as per requirements of the system or requirements for optimal designing. In order to write scalable, flexible, maintainable, and reusable code:

- Single-responsibility principle (SRP)
- Open-closed principle (OCP)
- Liskov’s Substitution Principle(LSP)
- Interface Segregation Principle (ISP)
- Dependency Inversion Principle (DIP)

It’s important to keep in mind that SOLID principles are just guidelines and not strict rules to be followed. The key is to strike a balance between flollowing these principles and considering the specific needs and constraints of your business requirement.
